---
title: "Supplementary Material: Data Preparation"
author: "Matthew Lincoln"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Supplementary Material}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r libraries}
library(dplyr)
library(readr)
library(stringr)
library(lubridate)
library(gtools)
```

The Getty Provenance Index staff has supplied us with a CSV export of their
database for all sales of _paintings_ made by auction houses _in London_. We
will first load this table into the R data processing environment, and make a
working copy of it.

```{r load_data}
# Specify the correct column names
correct_cols <- c(
  "cat_no",
  "lot_no",
  "artist_name_1",
  "artist_name_2",
  "artist_name_3",
  "artist_name_4",
  "artist_name_5",
  "title",
  "annotations",
  "object_type",
  "object_notes",
  "inscription",
  "seller",
  "transaction",
  "buyer",
  "lot_notes",
  "previous_owner",
  "previous_sales",
  "post_owner",
  "post_sales",
  "sale_date",
  "expert",
  "commissaire",
  "auction_house",
  "sale_location",
  "lugt_no")

# Read in CSV with the given column headers
base_sales <- read_csv("../data-raw/all_england.csv", skip = 1, col_names = correct_cols, col_types = "cccccccccccccccccccccccccc")

# Create a working data frame for all newly-generated columns
sales <- base_sales

# Number of records:
nrow(sales)
```

Having loaded the data, we perform several cleaning operations to extract sturctured information from the semi-structured text entered in many fields of the Getty database.

## Object type and Sale location

We will only keep records for sales of _paintings_ that took place in _London, England_

```{r object_types}
# Consider only paintings sold in London
sales <- sales %>% filter(object_type == "Painting" & sale_location == "London, England")

# Number of records:
nrow(sales)
```

## Dates

The original data contained several different variations on dates for each sale.
While most were in the format `YYYY MMM DD`, many lots are listed with the full
range of dates their sales took place in, and the exact day of the lot sale
specified after this. If an exact date was specified for a lot, we assigned that
date. If only a range was given, we used the first date of the given range.

```{r parse_dates}
# This function deals with two cases. Where specific dates per lot are
# mentioned, the function retrieves that date. When no specific lot is
# mentioned, then the first combination of year, month, and day are taken to be
# the date.

sales$date_string <- ifelse(
  # Check if a specific lot is mentioned
  str_detect(sales$sale_date, "This Lot"),
  # If so, extract the specific lot date
  paste(str_match(sales$sale_date, "(\\d{4}?)")[,2], str_match(sales$sale_date, "This Lot: (.{6})")[,2], sep = " "),
  # If not, extract the first complete date mentioned
  str_match(sales$sale_date, "^(\\d{4} \\w{3}? \\d{1,2})")[,2]
)

# Having constructed date text for each individual lot, we now use R's
# date-parsing functions to convert these into standard date formats.
sales$date <- ymd(sales$date_string)

# From this standard date field, we will derive additional integer values for
# year, month, week of the year, day of the year, day of the month, day of the
# week.

sales$year <- year(sales$date)
sales$month <- month(sales$date)
sales$week <- week(sales$date)
sales$yday <- yday(sales$date)
sales$mday <- mday(sales$date)
sales$wday <- wday(sales$date)
```

This leaves about 1858 dates that are not fully described, e.g. that have only
the month of the sale, not the specific date. Because we are interested in the
timing of sales at the precision of days, we must exclude these
partially-documented sales from our analysis.

```{r exclude_undated}
sales <- sales %>% filter(!is.na(date))

# Number of records:
nrow(sales)
```
  
## Transaction types and amounts

Transaction information involves both categorical descriptions of transaction
types (sold, bought in, etc.) and, in some cases, a recorded transaction amount.
The Getty database concatenates this information into a single text field, so we
will have to extract both the categorical and numeric information from it.

```{r transaction_extraction}
# Capture transaction type information recorded in the first segment of the transaction column
sales$transaction_type <- tolower(trimws(str_match(sales$transaction, "^([A-Za-z ]+)")[,2]))

# Capture numeric information contained in the second half of the transaction column
sales$transaction_amt <- str_match(sales$transaction, ",\\s*(\\d+[[:punct:]]?\\d*)")[,2]
# Fix up odd punctuation and convert to numeric
sales$transaction_amt <- as.numeric(str_replace(sales$transaction_amt, "[[:punct:]]", "."))

# Provisional sum of sale prices:
sum(sales$transaction_amt, na.rm = TRUE)
```

In many cases, several lots are grouped with the same transaction, so the same
price has been assigned to multiple lots. This is marked one of several ways in
the documentation:

- `...for lots 123 & 124` In the case of two lots, the presence of an `&` is signal that the given transaction amount should be divided by 2.
- `...for lots 123[a-d]` In the case of more than two lots per transaction, most sales are marked with a bracket notation. We can detect the number of lots indicated in this notation by checking the trailing letter (e.g. `a-d` marks 4 lots, `a-i` marks 9) and divide the transaction amount accordingly.

```{r multiple_transactions}
# Locate transactions with two or three lots as indicated by an & symbol, and
# divide acordingly
num_and <- str_count(sales$transaction, "&")
sales$transaction_amt <- ifelse(
  num_and == 0,
  sales$transaction_amt,
  ifelse(
    num_and == 1,
    sales$transaction_amt/2,
    sales$transaction_amt/3)
)

# Provisional sum of sale prices:
sum(sales$transaction_amt, na.rm = TRUE)

# For lots marked with bracket notation, determine the trailing letter and 
# divide the transaction amount accordingly. Where there is no trailing letter,
# preserve the same value.
sales$bracket_letter <- str_match(sales$transaction, "\\[a-([a-z])\\]")[,2]
sales$bracket_letter[is.na(sales$bracket_letter)] <- "none"
sales$transaction_amt <- ifelse(sales$bracket_letter == "c", sales$transaction_amt/3, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "d", sales$transaction_amt/4, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "e", sales$transaction_amt/5, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "f", sales$transaction_amt/6, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "g", sales$transaction_amt/7, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "h", sales$transaction_amt/8, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "i", sales$transaction_amt/9, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "j", sales$transaction_amt/10, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "k", sales$transaction_amt/11, sales$transaction_amt)

# Provisional sum of sale prices:
sum(sales$transaction_amt, na.rm = TRUE)
```

## Price factor

Due to inflation and deflation, it is difficult to compare absolute prices
across the period of study. A simple solution to this problem is to categorize
artworks into groups of most expensive and least expensive within their own
years. The following function will group artowrks by year and split them into 5
buckets within their year, based on their price relative to other

```{r price_factor}
sales <- sales %>% 
  group_by(year) %>% 
  mutate(price_factor = ntile(transaction_amt, n = 5))
```


