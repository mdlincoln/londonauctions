---
title: "Supplementary Material: Data Preparation"
author: "Matthew Lincoln"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Supplementary Material: Data Preparation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r libraries}
library(dplyr)
library(readr)
library(stringr)
library(lubridate)
```

# Paintings sales

The Getty Provenance Index staff has supplied us with a text export of their
database for all sales of _paintings_ made by auction houses _in London_. We
will first load this table into the R data processing environment, and make a
working copy of it.

```{r load_data}
# Read in the original data file as one long column of text
one_col <- data_frame(text = read_lines(system.file("extdata", "britishsales.txt", package = "londonauctions")))

# These are the variables we want to preserve for each record
req_vars <- c("--RECORD NUMBER--", "Edit Status", "Lot Sale Date", "Sale Begin Date", "Sale End Date", "Transaction", "Price")

base_sales <- one_col %>%
  # Split the single column of text into two cols: variable and value
  separate(text, into = c("variable", "value"), sep = 17) %>%
  # Trim any whitespace from either column
  mutate(variable = str_trim(variable), value = str_trim(value)) %>%
  # Only keep those rows that are in the req_vars list
  filter(variable %in% req_vars) %>%
  # To group a set of rows with a particular object, create an id column that
  # increments +1 each time it hits a "--RECORD NUMBER--" row
  mutate(objnum = cumsum(variable == "--RECORD NUMBER--")) %>%
  # Now spread() the table into one column per variable, and one row per observation
  spread(variable, value) %>% 
  # And rename column variables to be more standardized
  select(objnum, is_edited = `Edit Status`, sale_date = `Lot Sale Date`, sale_begin = `Sale Begin Date`, sale_end = `Sale End Date`, transaction_type = Transaction, amt = Price)


# Create a working data frame for all newly-generated columns
sales <- base_sales

# Number of records:
nrow(sales)
```

Having loaded the data, we perform several cleaning operations to extract sturctured information from the semi-structured text entered in many fields of the Getty database.

## Dates

The original data contained several different variations on dates for each sale.
While most were in the format `YYYY MMM DD`, many lots are listed with the full
range of dates their sales took place in, and the exact day of the lot sale
specified after this. If an exact date was specified for a lot, we assigned that
date. If only a range was given, we used the first date of the given range.

```{r parse_dates}
# This function deals with two cases. Where specific dates per lot are
# mentioned, the function retrieves that date. When no specific lot is
# mentioned, then the first combination of year, month, and day are taken to be
# the date.

sales$date_string <- ifelse(
  # Check if a specific lot is mentioned
  str_detect(sales$sale_date, "This Lot"),
  # If so, extract the specific lot date
  paste(str_match(sales$sale_date, "(\\d{4}?)")[,2], str_match(sales$sale_date, "This Lot: (.{6})")[,2], sep = " "),
  # If not, extract the first complete date mentioned
  str_match(sales$sale_date, "^(\\d{4} \\w{3}? \\d{1,2})")[,2]
)

# Having constructed date text for each individual lot, we now use R's
# date-parsing functions to convert these into standard date formats.
sales$date <- ymd(sales$date_string)

# From this standard date field, we will derive additional integer values for
# year, month, week of the year, day of the year, day of the month, day of the
# week.

sales$year <- year(sales$date) %>% as.integer()
sales$month <- month(sales$date) %>% as.integer()
sales$week <- week(sales$date) %>% as.integer()
sales$yday <- yday(sales$date) %>% as.integer()
sales$mday <- mday(sales$date) %>% as.integer()
sales$wday <- wday(sales$date) %>% as.integer()
```

This leaves about 1858 dates that are not fully described, e.g. that have only
the month of the sale, not the specific date. Because we are interested in the
timing of sales at the precision of days, we must exclude these
partially-documented sales from our analysis.

```{r exclude_undated}
sales <- sales %>% filter(between(year, 1780, 1840))

# Number of records:
nrow(sales)
```
  
## Transaction types and amounts

Transaction information involves both categorical descriptions of transaction
types (sold, bought in, etc.) and, in some cases, a recorded transaction amount.
The Getty database concatenates this information into a single text field, so we
will have to extract both the categorical and numeric information from it.

```{r transaction_extraction}
# Capture transaction type information recorded in the first segment of the transaction column
sales$transaction_type <- tolower(trimws(str_match(sales$transaction, "^([A-Za-z ]+)")[,2]))

# Capture numeric information contained in the second half of the transaction column
sales$transaction_amt <- str_match(sales$transaction, ",\\s*(\\d+[[:punct:]]?\\d*)")[,2]
# Fix up odd punctuation and convert to numeric
sales$transaction_amt <- as.numeric(str_replace(sales$transaction_amt, "[[:punct:]]", "."))

# Provisional sum of sale prices:
sum(sales$transaction_amt, na.rm = TRUE)
```

In many cases, several lots are grouped with the same transaction, so the same
price has been assigned to multiple lots. This is marked one of several ways in
the documentation:

- `...for lots 123 & 124` In the case of two lots, the presence of an `&` is signal that the given transaction amount should be divided by 2.
- `...for lots 123 & 124 & 125` In the case of three lots, the presence 2 `&`s is signal that the given transaction amount should be divided by 3.
- `...for lots 123[a-d]` In the case of more than two lots per transaction, some sales are marked with a bracket notation. We can detect the number of lots indicated in this notation by checking the trailing letter (e.g. `a-d` marks 4 lots, `a-i` marks 9) and divide the transaction amount accordingly.

```{r multiple_transactions}
# Locate transactions with two or three lots as indicated by an & symbol, and
# divide acordingly
num_and <- str_count(sales$transaction, "&")
sales$transaction_amt <- ifelse(
  num_and == 0,
  sales$transaction_amt,
  ifelse(
    num_and == 1,
    sales$transaction_amt/2,
    sales$transaction_amt/3)
)

# Provisional sum of sale prices:
sum(sales$transaction_amt, na.rm = TRUE)

# For lots marked with bracket notation, determine the trailing letter and 
# divide the transaction amount accordingly. Where there is no trailing letter,
# preserve the same value.
sales$bracket_letter <- str_match(sales$transaction, "\\[a-([a-z])\\]")[,2]
sales$bracket_letter[is.na(sales$bracket_letter)] <- "none"
sales$transaction_amt <- ifelse(sales$bracket_letter == "c", sales$transaction_amt/3, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "d", sales$transaction_amt/4, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "e", sales$transaction_amt/5, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "f", sales$transaction_amt/6, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "g", sales$transaction_amt/7, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "h", sales$transaction_amt/8, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "i", sales$transaction_amt/9, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "j", sales$transaction_amt/10, sales$transaction_amt)
sales$transaction_amt <- ifelse(sales$bracket_letter == "k", sales$transaction_amt/11, sales$transaction_amt)

# Provisional sum of sale prices:
sum(sales$transaction_amt, na.rm = TRUE)
```

## Price factor

Due to inflation and deflation, it is difficult to compare absolute prices
across the period of study. A simple solution to this problem is to categorize
artworks into groups of most expensive and least expensive within their own
years. The following function will group artowrks by year and split them into 5
buckets within their year, based on their price relative to other

```{r price_factor}
sales <- sales %>% 
  group_by(year) %>% 
  mutate(price_factor = ntile(transaction_amt, n = 5)) %>% 
  ungroup()
```

```{r save_data, eval = FALSE}
# Select pertinent columns of data and save for analyses
sales <- sales %>% 
  select(cat_no, lot_no, auction_house, date, transaction_type, transaction_amt, year, month, week, yday, mday, wday, price_factor)
```

# Royal Academy dates

Royal Academy Archivist Mark Pomeroy. Years 1769--1982 are ready for parsing ---
the remainder are incomplete. Here we convert the year, month, and day fields in
the original table into formatted date columns ready for processing.

```{r parse_ra_data}
raw_ra <- read_csv(system.file("extdata", "ra_dates.csv", package = "londonauctions"), col_types = "iiiii")

ra_dates <- raw_ra %>%
  mutate(
    start_string = paste(start_day, start_month, year, sep = "-"),
    end_string = paste(end_day, end_month, year, sep = "-"),
    exhib_start = start_string %>% dmy(),
    exhib_end = end_string %>% dmy(),
    exhib_start_day = yday(exhib_start) %>% as.integer(),
    exhib_end_day = yday(exhib_end) %>% as.integer(),
    exhib_year = year(exhib_start) %>% as.integer()
  ) %>%
  select(contains("exhib"))
```

# Parliament dates

```{r parse_parliament_data}
parliament_dates <- read_csv(system.file("extdata", "parliament_dates.csv", package = "londonauctions")) %>% 
  select(
    par_start = start_date,
    par_end = end_date,
    par_start_year = start_year,
    par_end_year = end_year,
    par_start_day = start_yday,
    par_end_day = end_yday
  )
```
